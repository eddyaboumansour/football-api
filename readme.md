# API de Gestion d'une Ã‰quipe de Football

## Ã‰noncÃ©

On aimerait pouvoir crÃ©er une API pour gÃ©rer lâ€™Ã©quipe de football de Nice en Ligue 1. Le directeur sportif du club
souhaite rÃ©pertorier en base de donnÃ©es la liste de ses joueurs et le budget de lâ€™Ã©quipe afin de mieux gÃ©rer le marchÃ©
des transferts Ã  venir.

### Consignes

DÃ©velopper une API REST avec les fonctionnalitÃ©s suivantes (lâ€™ajout de fonctionnalitÃ©s supplÃ©mentaires sera considÃ©rÃ©
comme un bonus) :

- Retourner une liste paginÃ©e dâ€™Ã©quipes contenant chacune une liste de joueurs. Cette liste pourra Ãªtre triÃ©e cÃ´tÃ©
  serveur (tri par nom dâ€™Ã©quipe, acronyme et budget).

- Ajouter une Ã©quipe avec ou sans joueurs associÃ©s (tous les autres champs sont obligatoires).

### Environnement technique

- **Framework** : Spring Boot

- **ORM** : Hibernate

- **Base de donnÃ©es** : Au choix (embarquÃ©, PostgreSQL, Oracle, etc.)

### ModÃ¨le de donnÃ©es

- **Ã‰quipe** : `[id, name, acronym, joueurs, budget]`

- **Joueur** : `[id, name, position]`

### Ã‰valuation

Les Ã©lÃ©ments suivants seront pris en compte lors de lâ€™Ã©valuation du projet :

- Architecture

- Choix techniques

- Documentation (Commentaires / Javadoc / Logs)

- Tests unitaires et dâ€™intÃ©gration

----------

## Description de l'API

Cette API Spring Boot permet de gÃ©rer des Ã©quipes de football et leurs joueurs. Elle propose des endpoints pour lister
les Ã©quipes, ajouter une nouvelle Ã©quipe, supprimer une Ã©quipe, et rÃ©cupÃ©rer les joueurs non assignÃ©s.

### Endpoints

#### 1. `/team/list` (GET)

- **Description** : RÃ©cupÃ¨re une liste paginÃ©e et triÃ©e dâ€™Ã©quipes.

- **ParamÃ¨tres** :

    - `sort` : Tri (nom, acronyme, budget)

    - `pageRequest` : Pagination (numÃ©ro de page, taille)

- **RÃ©ponse** : Une page dâ€™Ã©quipes reprÃ©sentÃ©es sous forme de `TeamDTO`.

- **Exemple** :

  ```
  GET /team/list?sort=name&pageRequest.page=0&pageRequest.size=10
  ```

#### 2. `/team` (POST)

- **Description** : Ajoute une nouvelle Ã©quipe.

- **Corps de la requÃªte** : Un objet `TeamCreateDTO` contenant les dÃ©tails de lâ€™Ã©quipe.

- **RÃ©ponse** : Lâ€™Ã©quipe crÃ©Ã©e sous forme de `TeamDTO`.

- **Exemple** :

  ```
  POST /team
  Content-Type: application/json
  {
    "name": "OGC Nice",
    "acronym": "OGCN",
    "budget": 50000000,
    "players": [
      { "name": "Joueur1", "position": "Attaquant" }
    ]
  }
  ```

#### 3. `/team/{id}` (DELETE) (Bonus)

- **Description** : Supprime une Ã©quipe par son ID et dÃ©saffecter les joueurs de l'Ã©quipe

- **Exemple** :

  ```
  DELETE /team/1
  ```

#### 4. `/player/available-players` (GET) (Bonus)

- **Description** : Liste les joueurs non assignÃ©s Ã  une Ã©quipe. Sert Ã  afficher une liste des joueurs non assignÃ©s Ã 
  une Ã©quipe dans le frontend

- **RÃ©ponse** : Une liste de `PlayerDTO`.

- **Exemple** :

  ```
  GET /player/available-players
  ```

----------

## Configuration de la Base de DonnÃ©es

- **PostgreSQL** :

  ```
  spring.datasource.url=jdbc:postgresql://localhost:5432/postgres
  spring.datasource.username=postgres
  spring.datasource.password=postgres
  ```

- **Liquibase** : Active par dÃ©faut pour gÃ©rer les migrations de schÃ©ma. DÃ©sactivable via
  `spring.liquibase.enabled=false` pour optimiser le dÃ©marrage de l'application.

## Choix Techniques

----------


### **1. Spring Boot 3.1.5**

Jâ€™ai choisi **Spring Boot** pour simplifier le dÃ©veloppement dâ€™applications Java, notamment des API REST. La version
3.1.5 apporte des amÃ©liorations de performance et une meilleure compatibilitÃ© avec Jakarta EE 10.

#### ğŸ”¹ **Cas dâ€™usage :**

- **DÃ©veloppement dâ€™API REST** : CrÃ©ation de microservices exposant des endpoints REST avec des contrÃ´leurs Spring (
  `@RestController`).

----------

### **2. JPA (Java Persistence API)**

Jâ€™ai choisi **JPA** pour gÃ©rer la persistance des objets mÃ©tier dans une base de donnÃ©es relationnelle. Il sâ€™agit dâ€™une
spÃ©cification standard gÃ©nÃ©ralement implÃ©mentÃ©e par Hibernate.

#### ğŸ”¹ **Cas dâ€™usage :**

- **Gestion des entitÃ©s** : Mapping des objets Java vers des tables SQL grÃ¢ce aux annotations comme `@Entity`, `@Table`,
  `@Column`.
- **RequÃªtes simplifiÃ©es** : Utilisation de `@Query` avec Spring Data JPA pour exÃ©cuter des requÃªtes spÃ©cifiques sans
  Ã©crire de SQL complexe.
- **Gestion des relations** : DÃ©finition des relations entre entitÃ©s (`@OneToMany`, `@ManyToOne`, `@ManyToMany`) pour
  structurer la base de donnÃ©es efficacement.
- **Pagination et tri** : Utilisation de `Pageable` pour rÃ©cupÃ©rer des rÃ©sultats paginÃ©s et triÃ©s sans surcharge de la
  base de donnÃ©es.
- **Gestion des transactions** : Utilisation des annotations @Transactional pour garantir lâ€™intÃ©gritÃ© des donnÃ©es lors
  des opÃ©rations critiques.
- **Utilisation de `EntityGraph` pour Ã©viter le problÃ¨me "N + 1"** : Cela permet de charger les joueurs associÃ©s en une
  seule requÃªte lors de la rÃ©cupÃ©ration des Ã©quipes. La propriÃ©tÃ© `spring.jpa.show-sql` est dÃ©sactivÃ©e par dÃ©faut.
- **CrÃ©ation dâ€™un index sur le champ `team_id`** : Cela permet dâ€™effectuer des requÃªtes rapides pour obtenir les joueurs
  par Ã©quipe et permettre de facilement set le team_id Ã  null lors de la suppression dâ€™une Ã©quipe.

----------

### **3. Hibernate**

Jâ€™ai choisi **Hibernate** comme implÃ©mentation de JPA pour faciliter la gestion des donnÃ©es en Ã©vitant dâ€™Ã©crire des
requÃªtes SQL complexes.

#### ğŸ”¹ **Cas dâ€™usage :**

- **Persistance des entitÃ©s** : Transformation automatique des objets Java en tables SQL et inversement.
- **Optimisation des performances** : Utilisation des caches de premier et second niveau pour minimiser les accÃ¨s Ã  la
  base de donnÃ©es.
- **Gestion des transactions** : Utilisation des annotations `@Transactional` pour garantir lâ€™intÃ©gritÃ© des donnÃ©es lors
  des opÃ©rations critiques.
- **Validation des paramÃ¨tres avec Hibernate Validation** : Hibernate Validation est utilisÃ© pour vÃ©rifier la validitÃ©
  des paramÃ¨tres des requÃªtes.

----------

### **4. Base de DonnÃ©es PostgreSQL**

Jâ€™ai choisi **PostgreSQL** comme base de donnÃ©es relationnelle pour sa fiabilitÃ©, sa scalabilitÃ© et son intÃ©gration
native avec Spring Data JPA.

#### ğŸ”¹ **Cas dâ€™usage :**

- **Stockage des donnÃ©es applicatives** : Utilisation avec Hibernate pour gÃ©rer les relations entre entitÃ©s et les
  transactions.

----------

### **5. Liquibase**

Jâ€™ai choisi **Liquibase** pour versionner et gÃ©rer les Ã©volutions du schÃ©ma de base de donnÃ©es de maniÃ¨re automatisÃ©e,
Ã©vitant les interventions manuelles.

#### ğŸ”¹ **Cas dâ€™usage :**

- **Automatisation des migrations** : DÃ©finition des changements de structure via des fichiers YAML, XML ou SQL
  appliquÃ©s automatiquement (Les fichiers sont prÃ©sent dans db.changelog).
- **Rollback des versions** : Restauration dâ€™une version prÃ©cÃ©dente en cas dâ€™erreur de dÃ©ploiement sur un environnement
  Ã  travers le changelog.
- **Suivi des changements** : Chaque modification est enregistrÃ©e dans une table de suivi, garantissant une traÃ§abilitÃ©
  complÃ¨te des Ã©volutions de la base de donnÃ©es.
- **Synchronisation des bases sur plusieurs environnements** : Assurer que la base de donnÃ©es en production, en test et
  en dÃ©veloppement reste cohÃ©rente.

----------

### **6. MapStruct**

Jâ€™ai choisi **MapStruct** pour automatiser le mapping entre entitÃ©s et DTOs avec PlayerMapper et TeamMapper, rÃ©duisant
ainsi le code rÃ©pÃ©titif et accÃ©lÃ©rant le dÃ©veloppement.

#### ğŸ”¹ **Cas dâ€™usage :**

- **Conversion des entitÃ©s vers DTOs** : Transformation des objets mÃ©tier en objets adaptÃ©s aux Ã©changes via API sans
  code rÃ©pÃ©titif.
- **Mapping conditionnel** : Filtrage de certains champs en fonction des besoins mÃ©tier.
- **Optimisation des performances** : GÃ©nÃ©ration de code natif au lieu dâ€™utiliser la rÃ©flexion, amÃ©liorant ainsi la
  rapiditÃ© des mappings.

----------

### **7. Lombok**

Jâ€™ai choisi **Lombok** pour rÃ©duire le code standard (boilerplate) en gÃ©nÃ©rant automatiquement des mÃ©thodes comme les
getters, setters et constructeurs grÃ¢ce Ã  des annotations.

#### ğŸ”¹ **Cas dâ€™usage :**

- **RÃ©duction du code rÃ©pÃ©titif** : Suppression des dÃ©clarations manuelles de `toString()`, `equals()` et `hashCode()`.
- **Utilisation des `@Builder` et `@AllArgsConstructor`** : Construction dâ€™objets complexes avec une syntaxe fluide.
- **AmÃ©lioration de la lisibilitÃ© du code** : Moins de code technique, rendant les classes plus comprÃ©hensibles.

----------

### **8. SpringDoc OpenAPI**

Jâ€™ai choisi **SpringDoc OpenAPI** pour documenter les API REST et permettre de tester facilement les endpoints via une
interface Swagger.

#### ğŸ”¹ **Cas dâ€™usage :**

- **Documentation dynamique** : Exposition des endpoints avec leurs paramÃ¨tres et rÃ©ponses sous une interface
  interactive.
- **Tests rapides des API** : ExÃ©cution directe des requÃªtes depuis Swagger UI sans passer par un client externe (
  Postman, cURL).
- **GÃ©nÃ©ration de spÃ©cifications OpenAPI** : Production automatique de fichiers JSON ou YAML conformes aux standards
  dâ€™API documentation.

----------

### **9. JUnit et Mockito**

Jâ€™ai choisi **JUnit et Mockito** pour tester mon application en isolant les composants et en simulant les dÃ©pendances.

#### ğŸ”¹ **Cas dâ€™usage :**

- **Tests unitaires des services mÃ©tier** : VÃ©rification du bon fonctionnement des mÃ©thodes de services en simulant
  leurs dÃ©pendances.
- **Mocking des dÃ©pendances** : Utilisation de Mockito pour tester une classe sans interagir avec des bases de donnÃ©es
  rÃ©elles ou dâ€™autres services.
- **Tests dâ€™intÃ©gration** : Validation du comportement global des API en sâ€™assurant que les diffÃ©rentes couches
  interagissent correctement.
- **ScÃ©nario couvert** : CrÃ©ation dâ€™une Ã©quipe avec des joueurs, puis suppression de lâ€™Ã©quipe.

## Installation et ExÃ©cution

### 1. PrÃ©requis

- Java 17

- Maven

- PostgreSQL (ou base embarquÃ©e)

### 2. Cloner le projet

```
git clone https://url.du.dÃ©pÃ´t.git
cd football-api
```

### 3. Construire et ExÃ©cuter lâ€™application

```
mvn clean install
mvn spring-boot:run
```

### 4. AccÃ¨s Ã  lâ€™API

- API : `http://localhost:8080`

- Documentation Swagger : `http://localhost:8080/swagger-ui.html`
- Une simple interface frontend (Bonus) : `http://localhost:8080/index.html`

